/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package github.live.tracker.app;

import io.rsocket.SocketAcceptor;
import io.rsocket.core.RSocketServer;
import io.rsocket.transport.netty.server.CloseableChannel;
import io.rsocket.transport.netty.server.TcpServerTransport;
import reactor.core.Disposable;
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;
import reactor.netty.http.client.HttpClient;

import java.sql.SQLException;
import java.time.Duration;

public class App {

//    public static void main(String[] args) {
//        LinkedList tokens;
//        tokens = split(getMessage());
//        System.out.println(join(tokens));
//    }

    public static void main(String[] args) throws SQLException, InterruptedException {

        SocketAcceptor echoAcceptor =
            SocketAcceptor.forRequestChannel(
                payloads ->
                    Flux.from(payloads)
                        .doOnNext(payload -> {
                            System.out.println("Meta: " + payload.getMetadataUtf8());
                            System.out.println("Data: " + payload.getDataUtf8());
                        })
//                        .map(Payload::getDataUtf8)
//                        .map(s -> "Echo: " + s)
//                        .map(DefaultPayload::create)
            );

        RSocketServer.create(echoAcceptor)
            .bind(TcpServerTransport.create("localhost", 7000))
            .subscribe();

        Thread.sleep(100000000000000000L);

//        CloseableConnectionFactory connectionFactory = H2ConnectionFactory.inMemory("tracker");
//        H2Connection connection = connectionFactory.create().block();
//
//        String statement =
//            "create table keyword_record (" +
//                "keyword varchar(255), " +
//                "source varchar(255), " +
//                "sha varchar(255), " +
//                "index_timestamp current_timestamp, " +
//                "record clob" +
//            ")";
//
//        connection
//            .createStatement(statement)
//            .execute()
//            .doOnNext(System.out::println)
//            .blockLast();
//
//                connection
//            .createStatement("INSERT INTO KEYWORD_RECORD ('KEYWORD', 'SOURCE', 'RECORD') VALUES ($1, $2, $3)")
//            .bind("$1", "KEYWORD")
//            .bind("$2", "SOURCE")
//            .bind("$3", "{\"record\": 123}")
//            .execute()
//            .doOnNext(System.out::println)
//            .blockLast();

//
//        connection
//            .createStatement("create table keyword_record (name varchar(255) not null)")
//            .execute()
//            .doOnNext(System.out::println)
//            .blockLast();
//
//        connection
//            .createStatement("select * from keyword_record")
//            .execute()
//            .doOnNext(System.out::println)
//            .blockLast();

//        connection
//            .createStatement("INSERT INTO KEYWORD_RECORD ('KEYWORD', 'SOURCE', 'RECORD') VALUES ($1, $2, $3)")
//            .bind("$1", "KEYWORD")
//            .bind("$2", "SOURCE")
//            .bind("$3", "{\"record\": 123}")
//            .execute()
//            .doOnNext(System.out::println)
//            .blockLast();

//        HttpClient client = HttpClient.create();
//        String response =
//            client.get()
//                .uri("https://api.github.com/search/code?q=addClass+org:jquery")
//                .responseContent()
//                .aggregate()
//                .asString()
//                .block();

//        System.out.println("Response: " + response);

//        Unit unit = new Unit();
//        unit.startPolling();
//        Thread.sleep(1000 * 60);
//        unit.stopPolling();

//        SocketAcceptor echoAcceptor =
//            SocketAcceptor.forRequestChannel(
//                payloads ->
//                    Flux.from(payloads)
//                        .map(Payload::getDataUtf8)
//                        .map(s -> "Echo: " + s)
//                        .map(DefaultPayload::create));
//
//        RSocketServer.create(echoAcceptor)
//            .bind(TcpServerTransport.create("localhost", 7000))
//            .subscribe();
//
//        RSocket socket =
//            RSocketConnector.connectWith(TcpClientTransport.create("localhost", 7000)).block();
//
//        socket
//            .requestChannel(
//                Flux.interval(Duration.ofMillis(1000)).map(i -> DefaultPayload.create("Hello")))
//            .map(Payload::getDataUtf8)
//            .log()
//            .take(10)
//            .doFinally(signalType -> socket.dispose())
//            .then()
//            .block();
    }

    private static Flux<String> createDataFetcher() {
        HttpClient client = HttpClient.create();

        return Flux
            .interval(Duration.ofMillis(60 * 1000 / 10))
            .flatMap(interval -> client
                .get()
                .uri("https://api.github.com/search/code?q=addClass+org:jquery+s:indexed+o:desc")
                .responseContent()
                .aggregate()
                .asString()
            );
    }

    private static class Unit {

        private Disposable poll = null;

        void startPolling() {
            poll = createDataFetcher()
                .doOnNext(System.out::println)
                .subscribeOn(Schedulers.parallel())
                .subscribe();
        }

        void stopPolling() {
            if (poll != null) {
                poll.dispose();
            }
        }

    }
}
